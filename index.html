<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Isekai RPG - Holy Sword Update</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; user-select: none; -webkit-user-select: none; }
        
        /* Joystick (Bên trái) */
        #joystick-zone {
            position: absolute; bottom: 50px; left: 50px;
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.4);
            touch-action: none; z-index: 10;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            border-radius: 50%; transform: translate(-50%, -50%);
        }

        /* Nút tấn công (Bên phải) */
        #attack-btn {
            position: absolute; bottom: 60px; right: 50px;
            width: 90px; height: 90px;
            background: radial-gradient(circle, #ff4e50, #f9d423);
            border-radius: 50%; border: 4px solid white;
            color: white; font-size: 40px; display: flex;
            justify-content: center; align-items: center;
            touch-action: none; user-select: none; z-index: 10;
            box-shadow: 0 0 20px rgba(255, 100, 0, 0.6);
            transition: transform 0.1s;
        }
        #attack-btn:active { transform: scale(0.9); filter: brightness(1.2); }

        /* Loading */
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; background: rgba(0,0,0,0.85);
            padding: 20px; border-radius: 15px; font-family: Arial;
            text-align: center; pointer-events: none; border: 1px solid white;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>

    <div id="loading">Đang rèn Thánh Kiếm...<br>0%</div>
    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    <div id="attack-btn">⚔️</div>

    <script>
        // --- 1. CẤU HÌNH ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Ánh sáng
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 5);
        dirLight.castShadow = true;
        // Tối ưu shadow
        dirLight.shadow.mapSize.width = 512;
        dirLight.shadow.mapSize.height = 512;
        scene.add(dirLight);

        // Biến game
        let player, mixer, sword;
        const clock = new THREE.Clock();
        const loader = new THREE.GLTFLoader();
        const models = {}; 
        const colliders = [];
        const chunks = {};
        const slashes = []; // Chứa các tia kiếm khí đang bay
        
        const moveSpeed = 6; 
        const chunkSize = 20; 
        let moveInput = { x: 0, y: 0 };
        let isAttacking = false;

        // --- 2. LOAD FILES ---
        function loadModel(name, url) {
            return new Promise(resolve => {
                loader.load(url, (gltf) => {
                    models[name] = gltf.scene;
                    models[name].traverse(c => { 
                        if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; } 
                    });
                    resolve();
                }, xhr => {
                    document.getElementById('loading').innerHTML = `Đang tải... ${Math.round(xhr.loaded/xhr.total*100)}%`;
                }, err => resolve());
            });
        }

        Promise.all([
            loadModel('vip', 'vip.glb'),
            loadModel('dat', 'dat.glb'),
            loadModel('cay', 'cay.glb'),
            loadModel('da', 'da.glb')
        ]).then(() => {
            document.getElementById('loading').style.display = 'none';
            initGame();
        });

        // --- 3. INIT GAME ---
        function initGame() {
            // Player
            if (models.vip) {
                player = models.vip;
                player.scale.set(0.4, 0.4, 0.4); 
            } else {
                player = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 0.5), new THREE.MeshStandardMaterial({color:'red'}));
            }
            scene.add(player);

            // Gắn Thánh Kiếm
            createHolySword();

            // Animation
            if (player.animations && player.animations.length > 0) {
                mixer = new THREE.AnimationMixer(player);
                mixer.clipAction(player.animations[0]).play();
            }

            // Nền xanh vô tận
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 500),
                new THREE.MeshLambertMaterial({ color: 0x48a14d })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);

            animate();
        }

        // --- 4. THÁNH KIẾM & KỸ NĂNG ---
        function createHolySword() {
            const swordGroup = new THREE.Group();
            
            // 1. Lưỡi kiếm (Thép sáng)
            const bladeGeo = new THREE.BoxGeometry(0.12, 1.8, 0.05);
            // Thu nhỏ phần mũi kiếm cho nhọn
            const posAttr = bladeGeo.attributes.position;
            // Chỉnh sửa đỉnh geometry thủ công để làm mũi nhọn
            // (Đơn giản hóa: dùng box shape màu sáng rực)
            const bladeMat = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff, // Màu Cyan sáng
                emissive: 0x004444, // Tự phát sáng nhẹ
                metalness: 0.9, 
                roughness: 0.1 
            });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.y = 0.9;
            
            // 2. Chuôi bảo vệ (Vàng)
            const guardGeo = new THREE.BoxGeometry(0.6, 0.1, 0.15);
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 1.0, roughness: 0.3 });
            const guard = new THREE.Mesh(guardGeo, goldMat);
            guard.position.y = 0.05;

            // 3. Tay cầm (Nâu)
            const handleGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.5, 8);
            const handleMat = new THREE.MeshStandardMaterial({ color: 0x4B3621 });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.25;

            // 4. Ngọc đính (Đỏ)
            const gemGeo = new THREE.IcosahedronGeometry(0.1, 0);
            const gemMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 });
            const gem = new THREE.Mesh(gemGeo, gemMat);
            gem.position.y = 0.05;
            gem.position.z = 0.05;

            swordGroup.add(blade, guard, handle, gem);

            // Gắn vào tay
            swordGroup.position.set(0.6, 1.4, 0.4); 
            swordGroup.rotation.x = Math.PI / 2; // Chĩa ra trước
            player.add(swordGroup);
            sword = swordGroup;
        }

        function createSlashEffect() {
            // Tạo hình cung (Kiếm khí)
            const geometry = new THREE.TorusGeometry(1.5, 0.1, 8, 20, Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffff00, // Màu vàng
                transparent: true, 
                opacity: 0.8 
            });
            const slash = new THREE.Mesh(geometry, material);

            // Đặt vị trí trước mặt nhân vật
            slash.position.copy(player.position);
            slash.position.y += 1.5; // Cao bằng tầm kiếm
            
            // Xoay theo hướng nhân vật
            slash.rotation.y = player.rotation.y; 
            slash.rotation.x = Math.PI / 2; // Nằm ngang bay đi (hoặc dựng đứng)
            // Chỉnh lại để nó dựng đứng như trăng khuyết bay đi
            slash.rotation.set(0, player.rotation.y, Math.PI / 2);

            scene.add(slash);

            // Lưu hướng bay
            const direction = new THREE.Vector3(0, 0, 1);
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);

            slashes.push({ mesh: slash, dir: direction, life: 0.5 }); // Tồn tại 0.5 giây
        }

        function attack() {
            if (isAttacking || !sword) return;
            isAttacking = true;
            
            // Tạo hiệu ứng kiếm khí
            createSlashEffect();

            // Hiệu ứng chém của nhân vật
            let duration = 0;
            const attackAnim = setInterval(() => {
                duration += 0.05;
                // Xoay kiếm chém xuống mạnh hơn
                sword.rotation.x = Math.PI / 2 + Math.sin(duration * 15) * 2.0;
                
                if (duration > 0.2) {
                    clearInterval(attackAnim);
                    sword.rotation.x = Math.PI / 2; 
                    isAttacking = false;
                }
            }, 16);
        }

        // --- 5. MAP & VAT LY ---
        function updateChunks() {
            if (!player) return;
            const pX = Math.floor(player.position.x / chunkSize);
            const pZ = Math.floor(player.position.z / chunkSize);

            for (let x = pX - 1; x <= pX + 1; x++) {
                for (let z = pZ - 1; z <= pZ + 1; z++) {
                    const key = `${x},${z}`;
                    if (!chunks[key]) {
                        createChunk(x, z);
                        chunks[key] = true;
                    }
                }
            }
        }

        function createChunk(cx, cz) {
            const rootX = cx * chunkSize;
            const rootZ = cz * chunkSize;

            // Đất
            if (models.dat) {
                const step = 5; 
                for(let i=0; i<4; i++) {
                    for(let j=0; j<4; j++) {
                        const dat = models.dat.clone();
                        dat.position.set(rootX + i*step, 0, rootZ + j*step);
                        dat.scale.set(5.1, 1, 5.1); 
                        scene.add(dat);
                    }
                }
            }

            // Cây đá ngẫu nhiên
            for (let i = 0; i < 4; i++) {
                const posX = rootX + Math.random() * chunkSize;
                const posZ = rootZ + Math.random() * chunkSize;
                const rand = Math.random();

                if (rand > 0.7 && models.da) {
                    const rock = models.da.clone();
                    rock.position.set(posX, 0, posZ);
                    const s = 1 + Math.random() * 4; 
                    rock.scale.set(s, s, s);
                    rock.rotation.y = Math.random() * 6;
                    scene.add(rock);
                    colliders.push({ mesh: rock, radius: s * 0.8 }); 
                }
                else if (rand < 0.3 && models.cay) {
                    const tree = models.cay.clone();
                    tree.position.set(posX, 0, posZ);
                    tree.scale.set(8, 8, 8); 
                    scene.add(tree);
                    colliders.push({ mesh: tree, radius: 1.5 });
                }
            }
        }

        function checkCollision(nextPos) {
            for (let obj of colliders) {
                const dx = nextPos.x - obj.mesh.position.x;
                const dz = nextPos.z - obj.mesh.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                if (dist < obj.radius + 0.4) return true;
            }
            return false;
        }

        // --- 6. CONTROLS (ĐÃ SỬA LỖI NGƯỢC) ---
        const joyZone = document.getElementById('joystick-zone');
        const joyKnob = document.getElementById('joystick-knob');
        let joyId = null; 
        let joyCenter = {x:0, y:0};

        joyZone.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            joyId = t.identifier;
            const rect = joyZone.getBoundingClientRect();
            joyCenter = {x: rect.left + rect.width/2, y: rect.top + rect.height/2};
            updateJoy(t);
        }, {passive:false});
        
        joyZone.addEventListener('touchmove', e => {
            e.preventDefault();
            [...e.changedTouches].forEach(t => { if(t.identifier === joyId) updateJoy(t); });
        }, {passive:false});

        joyZone.addEventListener('touchend', e => {
            [...e.changedTouches].forEach(t => {
                if(t.identifier === joyId) {
                    joyId = null;
                    joyKnob.style.transform = `translate(-50%,-50%)`;
                    moveInput = {x:0, y:0};
                }
            });
        });

        function updateJoy(t) {
            const max = 40;
            let dx = t.clientX - joyCenter.x;
            let dy = t.clientY - joyCenter.y; // Kéo lên là âm, xuống là dương
            
            const d = Math.sqrt(dx*dx + dy*dy);
            if(d > max) { dx *= max/d; dy *= max/d; }
            
            joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            
            // CHUẨN HÓA INPUT (SỬA LẠI LOGIC NGƯỢC)
            // Bình thường Joystick Web: Y âm là lên.
            // Nhưng trong tính toán góc, chúng ta cần map đúng.
            moveInput = { x: dx/max, y: dy/max };
        }

        document.getElementById('attack-btn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            attack();
        });

        // --- 7. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            // Cập nhật Tia Kiếm (Slash)
            for (let i = slashes.length - 1; i >= 0; i--) {
                const s = slashes[i];
                s.life -= dt;
                // Bay về phía trước
                s.mesh.position.addScaledVector(s.dir, 15 * dt); // Tốc độ bay 15
                // Xoay vòng vòng cho đẹp
                s.mesh.rotation.z += 10 * dt;

                if (s.life <= 0) {
                    scene.remove(s.mesh);
                    slashes.splice(i, 1);
                }
            }

            if (player) {
                updateChunks();

                if (moveInput.x !== 0 || moveInput.y !== 0) {
                    // SỬA LỖI ĐI NGƯỢC:
                    // Math.atan2(y, x) -> Góc 0 là bên phải.
                    // Joystick: x+ phải, y+ xuống.
                    // Chúng ta muốn: y- (Lên) -> Góc PI (Đi về Z âm).
                    
                    const angle = Math.atan2(moveInput.x, moveInput.y);
                    
                    const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), angle);
                    player.quaternion.slerp(q, 0.2);

                    const speed = moveSpeed * dt;
                    // Sửa hướng đi theo góc mới
                    const nextX = player.position.x + Math.sin(angle) * speed;
                    const nextZ = player.position.z + Math.cos(angle) * speed;

                    if (!checkCollision({x: nextX, z: nextZ})) {
                        player.position.x = nextX;
                        player.position.z = nextZ;
                    }
                }

                // Camera bám lưng
                const camDist = 5; 
                const camHeight = 3.5;
                const backOffset = new THREE.Vector3(0, camHeight, camDist);
                backOffset.applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
                const targetPos = player.position.clone().add(backOffset);
                camera.position.lerp(targetPos, 0.15); 
                camera.lookAt(player.position.x, player.position.y + 1.2, player.position.z); 

                if (mixer) mixer.update(dt);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>